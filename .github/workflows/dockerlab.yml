name: ci

on:
  push:
    branches:
      - 'main'

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      -
        name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      -
        name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      -
        name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.USER_DOCKERHUB }}
          password: ${{ secrets.PWD_DOCKERHUB }}
      -
        name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: "{{defaultContext}}:mariadb"
          push: true
          tags: chrisattineos/repoimageattineos:mariadb
      -
        name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: "{{defaultContext}}:wordpress"
          push: true
          tags: chrisattineos/repoimageattineos:wordpress
          
      - 
        name: Deploy Docker to AWS (EC2)
        uses: bitovi/github-actions-deploy-docker-to-ec2@v0.5.3
        with:
          # AWS access key ID
          aws_access_key_id: ${{ secrets.AWS_ACCESSKEY }}
          # AWS secret access key
          aws_secret_access_key: ${{ secrets.AWS_SECRETKEY }}
          # AWS session token
          aws_default_region: # optional, default is us-east-1
          # AWS AMI ID. Will default to the latest Ubuntu 22.04 server image (HVM) 
          aws_ami_id: # optional
          # AWS S3 bucket to use for Terraform state. Defaults to `${org}-${repo}-{branch}-tf-state`
          tf_state_bucket: # optional
          # Force purge and deletion of S3 bucket defined. Any file contained there will be destroyed. `stack_destroy` must also be `true`
          tf_state_bucket_destroy: # optional, default is false
          # Set to override the AWS resource identifier for the deployment.  Defaults to `${org}-{repo}-{branch}`.  Use with destroy to destroy specific resources.
          aws_resource_identifier: # optional
          # File containing environment variables to be used with the app
          repo_env: # optional, default is repo_env
          # `.env` file to be used with the app from Github secrets
          dot_env: # optional
          # `.env` file to be used with the app from Github variables
          ghv_env: # optional
          # Secret name to pull env variables from AWS Secret Manager
          aws_secret_env: # optional, default is 
          # Set to true to run docker-compose down and docker system prune --all --force --volumes after.
          docker_full_cleanup: # optional
          # Relative path for the directory of the app (i.e. where `Dockerfile` and `docker-compose.yaml` files are located). This is the directory that is copied to the EC2 instance.  Default is the root of the repo. Add a .gha-ignore file with a list of files to be exluded.
          app_directory: # optional
          # Will generate a timestamped compressed file and delete the app repo directory.
          app_directory_cleanup: # optional
          # Port to expose for the app
          app_port: # optional
          # Load balancer listening port. Defaults to 80 if NO FQDN provided, 443 if FQDN provided
          lb_port: # optional
          # Load balancer health check string. Defaults to HTTP:app_port
          lb_healthcheck: # optional
          # The AWS IAM instance profile to use for the EC2 instance
          ec2_instance_profile: # optional
          # The AWS Instance type
          ec2_instance_type: # optional
          # The size of the volume (in GB) on the AWS Instance
          ec2_volume_size: # optional, default is 8
          # Toggle to indicate whether to create and EFS and mount it to the ec2 as a part of the provisioning. Note: The EFS will be managed by the stack and will be destroyed along with the stack
          aws_create_efs: # optional
          # Toggle to indicate whether the EFS resource should be highly available (target mounts in all available zones within region)
          aws_create_ha_efs: # optional
          # Toggle to indiciate whether a read-only replica should be created for the EFS primary file system
          aws_create_efs_replica: # optional
          # Toggle to indiciate whether the EFS should have a backup policy, default is `false`
          aws_enable_efs_backup_policy: # optional
          # Information on Zone Mapping can be found in the [README.md](README.md#efs-zone-mapping)
          aws_efs_zone_mapping: # optional
          # Indicates how long it takes to transition files to the IA storage class
          aws_efs_transition_to_inactive: # optional
          # AWS Region to target for replication
          aws_replication_configuration_destination: # optional
          # ID of existing EFS
          aws_mount_efs_id: # optional
          # ID of the primary security group used by the existing EFS
          aws_mount_efs_security_group_id: # optional
          # Set to "true" to Destroy the stack. Will delete the elb_logs bucket after the destroy action runs.
          stack_destroy: # optional
          # Define the root domain name for the application. e.g. app.com
          domain_name: # optional
          # Define the sub-domain part of the URL. Defaults to `${org}-${repo}-{branch}`
          sub_domain: # optional
          # Deploy to root domain. Will generate two DNS recrods, one for root, another for www
          root_domain: # optional
          # Define the certificate ARN to use for the application
          cert_arn: # optional
          # Generates and manage the root cert for the application
          create_root_cert: # optional
          # Generates and manage the sub-domain certificate for the application
          create_sub_cert: # optional
          # Makes the application not to use a certificate by disabling certificate lookup.
          no_cert: # optional
          # A list of targets to create before the full stack creation. Example: `
          targets: # optional
          # A JSON object of additional tags that will be included on created resources. Example: `{"key1": "value1", "key2": "value2"}`
          additional_tags: # optional
          # Generates and manages a secret manager entry that contains the public and private keys created for the ec2 instance.
          create_keypair_sm_entry: # optional
          # Set to "true" to enable a postgres database
          aws_enable_postgres: # optional
          # Which Database engine to use
          aws_postgres_engine: # optional
          # Specify Postgres version
          aws_postgres_engine_version: # optional
          # Define the size of the instances in the DB cluster
          aws_postgres_instance_class: # optional
          # Specify which subnets to use as a list of strings.  Example: `i-1234,i-5678,i-9101`
          aws_postgres_subnets: # optional
          # Specify a database name. Will be created if it does not exist
          aws_postgres_database_name: # optional
          # Postgres database port
          aws_postgres_database_port: # optional
          # Postgres database group family
          aws_postgres_database_group_family: # optional
          # Protects the database from deletion.
          aws_postgres_database_protection: # optional
          # Generates a snapshot of the database before deletion.
          aws_postgres_database_final_snapshot: # optional
          # Directory path in application env to mount directory, default is `data`
          application_mount_target: # optional, default is data
          # Directory path within docker env to mount directory to, default is `/data`
          data_mount_target: # optional
          # Directory path in efs to mount directory to, default is `/`
          efs_mount_target: # optional
